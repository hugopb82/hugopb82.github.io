
<!DOCTYPE html>
<html lang="fr" dir="ltr">
	<head>
		<meta charset="utf-8">
  		<meta name="viewport" content="width=device-width, initial-scale=1.0" />

		<!-- MAIN STYLES -->
		<link rel="stylesheet" href="/css/master.css">

		<!-- PRISM -->
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/prismjs@1.24.0/plugins/line-numbers/prism-line-numbers.min.css,npm/prismjs@1.24.0/themes/prism.min.css">


<script defer type="text/javascript">
	function removeWS() {
		Prism.plugins.NormalizeWhitespace.setDefaults({
			'remove-trailing': true,
			'remove-indent': true,
			'left-trim': true,
			'right-trim': true,
		});
	}
</script>

<script onload="removeWS()" defer src="https://cdn.jsdelivr.net/combine/npm/prismjs@1.24.0,npm/prismjs@1.24.0/plugins/line-numbers/prism-line-numbers.min.js,npm/prismjs@1.24.0/plugins/autoloader/prism-autoloader.min.js,npm/prismjs@1.24.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js" charset="utf-8"></script>
		<!-- KATEX -->
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.5/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
<script defer>
	document.addEventListener("DOMContentLoaded", function() {
		renderMathInElement(document.body, {
			delimiters: [
				{left: "$$", right: "$$", display: true},
				{left: "$", right: "$", display: false}
			]
		});
	});
</script>
		<!-- MARKED -->
		<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script type="text/javascript">
	document.addEventListener("DOMContentLoaded", function() {
		document.querySelectorAll('article').forEach(el => {
			el.innerHTML = marked(el.innerHTML.replace(/\t/g, ''));
		});
	});
</script>	</head>
	<body>

		<article class="article">
			<section title="Rapport de stage">

	<section title="Le son">

	<section title="Définitions">

	Physiquement, le **son** est une vibration mécanique de l'air (ou plus généralement de tout autre fluide) qui se propage sous forme d'ondes longitudinales.

	<figure>
		<img src="assets/bases_son/propagation.gif" alt="">
		<figcaption>Illustration de la propagation d'une onde</figcaption>
	</figure>

	L'oreille humaine (ou celle du kangourou commun, mais ce n'est pas tellement le propos) mesure les variations de pressions à l'entrée du canal auditif.

	<figure>
		<img src="assets/bases_son/oreille.gif" alt="">
		<figcaption>Illustration du fonctionnement d'une oreille</figcaption>
	</figure>

</section>	<section title="Représentation d'une onde sonore">

	Une façon intuitive de représenter une onde sonore est de tracer les variations de pressions qu'elle engendre à un point $x$ en fonction du temps :

	<figure>
		<img src="assets/bases_son/waveform.png" alt="">
		<figcaption>Représentation d'une onde sonore</figcaption>
	</figure>

	Étudier un son va donc revenir à étudier une fonction / un signal (ce que l'on sait un peu faire, normalement).

</section>	<section title="Caractéristiques">

	Un son possède plusieurs caractéristiques (<a href="#wiki_son"></a>) que notre oreille peut déceler :
	- **sa direction d'origine** : vous savez dire si quelqu'un parle devant vous ou dans votre dos (mais on est d'accords, ça se fait trop pas)  
	Ceci est dû au fait que nous avons (si tout va bien) deux oreilles, qui captent les sons à des positions (encore une fois si tout va bien) légèrement différentes. Notre cerveau est alors capable de spatialiser le son.
	- **son intensité** : vous savez dire si quelqu'un parle fort ou doucement.  
	Concrètement, l'onde sonore déplace plus ou moins les particules d'air, ce qui se traduit par des variations de pressions plus ou moins importantes.
	<figure>
		<img src="assets/bases_son/intensite.png" alt="">
		<figcaption>Un son doux (à gauche) et fort (à droite)</figcaption>
	</figure> 
	- **sa hauteur** : vous savez dire si quelqu'un a une voix grave ou aigue  
	Ceci est lié à la fréquence de vibration de l'onde sonore : plus cette vibration est lente, plus le son est perçu comme grave (et inversement).  
	<figure>
		<img src="assets/bases_son/frequence.png" alt="">
		<figcaption>Un son grave (à gauche) et aigu (à droite)</figcaption>
	</figure>  
	(Note : j'utilise "vitesse de vibration" pour ne pas parler de "fréquence", que l'on réservera à des ondes sonores périodiques)
	- **son timbre** : vous savez distinguer plusieurs voix  
	Cela est lié à la forme de l'onde sonore : son enveloppe, ses harmoniques...


</section>	<section title="Son musicaux">

	Il existe des sons bien particuliers : les sons "musicaux". Un instrument de musique (ou une voix chantée) sonne bien différemment d'un marteau-piqueur.

	Cela vient du fait qu'un instrument de musique produit des sons **périodiques**, contrairement aux sons ordinaires qui sont **apériodiques**:

	<figure>
		<img src="assets/bases_son/vlvsmp.png" alt="">
		<figcaption>Onde sonore d'un violon (à gauche) et d'un marteau-piqueur (à droite)</figcaption>
	</figure>

</section>	<!-- <section title="Références" no-count>

	<ul>
		<li>
			<cite id="wiki_son">
				<a href="https://fr.wikipedia.org/wiki/Son_(physique)">Page wikipédia sur le son</a>
			</cite>
		</li>
	</ul>

</section> -->

</section>	<section title="Analyse de Fourier">

	L'analyse de Fourier est une branche des mathématiques qui consiste à étudier la décomposition de fonctions en sinusoïdes. Pourquoi des sinusoïdes ? Parce que ce sont les seuls signaux qui, donnés en entrée d'un **système linéaire**, engendrent une sortie sinusoïdale de même fréquence que la sinusoïde d'entrée. La décomposition de Fourier permet donc de faciliter l'étude de beaucoup de systèmes physiques.
	
	Ces techniques diffèrent suivant si la fonction est **continue** ou **discrète**, **périodique** ou **apériodique** :

	- la fonction est **continue** et **périodique** : on peut (sous certaines conditions) la décomposer en **série de Fourier** (*Fourier Series* en anglais)
	- la fonction est **continue** et **apériodique** : on peut peut (sous certaines conditions) généraliser la démarche précédente et calculer sa **transformée de Fourier** (*Fourier Transform* en anglais)
	- la fonction est **discrète** et **périodique** : on peut calculer sa **transformée de Fourier discrète** (*Discrete Fourier Transform* en anglais)
	- la fonction est **discrète** et **apériodique** : on peut généraliser la démarche précédente et calculer sa **transformée de Fourier à temps discret** (*Discrete Time Fourier Transform* en anglais)

	Pour la suite, ce qui nous intéresse avant tout est la troisième famille : les signaux discrets et périodiques. En effet, nous travaillerons sur ordinateur, où les signaux sont forcément discrétisés et finis. Nous considérerons que ces signaux finis sont en fait une période d'un signal discret infini hypothétique.

	<section title="Séries de Fourier">

	L'introduction précédente justifie la volonté de trouver une décomposition en somme de sinusoïdes. Donnons ici quelques intuitions.

	On se place ici dans le cas d'une fonction $f : \R \to \R$, $T$-périodique (donc de fréquence).

	On pose $\omega = \frac{2 \pi}{T}$, ce qui nous permet de considérer les fonctions trigonométriques de période $T$ : $t \mapsto \cos(\omega t)$ et $t \mapsto \sin(\omega t)$.

	Notre fonction étant $T$-périodique, on va essayer de la décomposer en sommes de sinusoïdes de pulsations multiples de $\omega$, c'est à dire trouver une décomposition telle que :
	
	$$ f(t) = \sum_{n = 0}^{+ \infty} a_n \cos(n \omega t) + b_n \sin(n \omega t) $$

	Supposons qu'une telle décomposition existe et essayons de trouver des contraintes sur les coefficients.

	En prenant l'intégrale sur une période il vient :

	$$ \int_{0}^{T} f(t) dt  = 
	\int_{0}^{T} \left( \sum_{n = 0}^{+ \infty} a_n \cos(n \omega t) + b_n \sin(n \omega t) \right) dt $$

	Supposons que l'on puisse intervertir l'intégrale et la somme :

	$$
	\begin{aligned}
	\int_{0}^{T} f(t) dt  
	&= \int_{0}^{T} \left( \sum_{n = 0}^{+ \infty} a_n \cos(n \omega t) + b_n \sin(n \omega t) \right) dt \\
	&= \sum_{n = 0}^{+ \infty} \left(  \int_{0}^{T}  a_n \cos(n \omega t) + b_n \sin(n \omega t) \right) dt
	\end{aligned}
	$$

	Or, à part pour $n=0$, ces sinusoïdes sont toutes $T$-périodiques. D'où :

	$$
	\\
	\begin{aligned}
		\int_{0}^{T} f(t) dt 	&= \int_{0}^{T} a_0 dt \\
								&= T a_0
	\end{aligned}
	$$

	On a donc $a_0 = \frac{1}{T} \int_{0}^{T} f(t) dt $

	Comment trouver les autres coefficients ? On peut remarquer les choses suivantes :

	$$
		\int_{-T/2}^{T/2} \cos(n \omega t) \sin(m \omega t) dt = 0
	$$

	$$
		\int_{-T/2}^{T/2} \cos(n \omega t) \cos(m \omega t) dt = 
		\begin{cases}
			0     	&\text{si } n \ne m \\
			T / 2 	&\text{si } n = m \ne 0 \\
			0 		&\text{si } n = m = 0 \\
		\end{cases}
	$$

	$$
		\int_{-T/2}^{T/2} \sin(n \omega t) \sin(m \omega t) dt = 
		\begin{cases}
			0     	&\text{si } n \ne m \ne 0 \\
			T / 2 	&\text{si } n = m \ne 0 \\
			T 		&\text{si } n = m = 0 \\
		\end{cases}
	$$

	Ainsi, pour trouver le coefficient $a_m$, on multiplie la série par $\cos(m \omega t)$ puis on procède de la même manière que précédemment :

	$$
		\begin{aligned}
			f(t) &= \sum_{n = 0}^{+ \infty} a_n \cos(n \omega t) + b_n \sin(n \omega t) \\
			f(t) \cos(m \omega t) &= \cos(m \omega t) \sum_{n = 0}^{+ \infty} a_n \cos(n \omega t) + b_n \sin(n \omega t) \\
			\int_{-T/2}^{T/2} f(t) \cos(m \omega t) dt &= \int_{-T/2}^{T/2} \left( \sum_{n = 0}^{+ \infty} a_n \cos(n \omega t) \cos(m \omega t) + b_n \sin(n \omega t) \cos(m \omega t) \right) dt \\
			\int_{-T/2}^{T/2} f(t) \cos(m \omega t) dt &= \sum_{n = 0}^{+ \infty} \left( \int_{-T/2}^{T/2}  a_n \cos(n \omega t) \cos(m \omega t) dt + \int_{-T/2}^{T/2} b_n \sin(n \omega t) \cos(m \omega t) dt \right) \\
			\int_{-T/2}^{T/2} f(t) \cos(m \omega t) dt &= a_m \frac{T}{2} \\
			a_m &= \frac{2}{T} \int_{-T/2}^{T/2} f(t) \cos(m \omega t) dt
		\end{aligned}
	$$

	De même, on trouve que :

	$$ b_m = \frac{2}{T} \int_{-T/2}^{T/2} f(t) \sin(m \omega t) dt $$


	Au final, s'il existe une décomposition en série de Fourier, alors les coefficients $a_n$ et $b_n$ doivent respecter :

	$$
		\begin{aligned}
			a_0 &= \frac{1}{T} \int_{0}^{T} f(t) dt \\
			a_n &= \frac{2}{T} \int_{-T/2}^{T/2} f(t) \cos(n \omega t) dt \qquad \text{ pour } n \geq 1 \\
			b_n &= \frac{2}{T} \int_{-T/2}^{T/2} f(t) \sin(n \omega t) dt \qquad \text{ pour } n \geq 1 \\
		\end{aligned}
	$$

	Enfin, en utilisant les formules d'Euler, il est possible d'obtenir une expression plus condensée :

	$$
		\begin{aligned}
			\sum_{n = 0}^{+ \infty} a_n \cos(n \omega t) + b_n \sin(n \omega t) &= \sum_{n = 0}^{+ \infty} \frac{a_n}{2} \left( e^{i n \omega t} + e^{-i n \omega t} \right) + \frac{b_n}{2i} \left( e^{i n \omega t} - e^{-i n \omega t} \right) \\
			&= \sum_{n = 0}^{+ \infty} e^{i n \omega t} \left( \frac{a_n}{2} - i \frac{b_n}{2} \right) + e^{-i n \omega t} \left( \frac{a_n}{2} + i \frac{b_n}{2} \right) \\
			&= \sum_{n = - \infty}^{+ \infty} c_n e^{i n \omega t} \\
		\end{aligned}
	$$

	Avec

	$$
		c_n = 
		\begin{cases}
			a_0 & \text{ pour } n = 0 \\
			\frac{a_n}{2} - i \frac{b_n}{2} & \text{ pour } n \gt 0 \\
			\overline{c_{-n}} & \text{ pour } n \lt 0 \\
		\end{cases}
	$$
	
</section>	<section title="Transformée de Fourier">

	

</section>		<section title="Transformée de Fourier à Court Terme (STFT)">

	

</section>
</section>	<section title="Séparation de sources">

	La séparation de sources est un des problèmes majeurs en traitement du son. Le but est d'essayer d'extraire les sons qui composent un mélange sonore (par exemple : extraire la partie "batterie" d'un morceau de musique).

	Notre cerveau est capable d'effectuer cette opération, même dans des conditions assez mauvaises : nous sommes par exemple capable de nous focaliser sur la voix d'une personne dans le brouhaha d'un restaurant. Cependant, cette prouesse est rendue possible par un apprentissage très long des nombreux sons qui nous entourent, et de leurs caractéristiques. Ces connaissances sont souvent difficilement traduisibles informatiquement, ce qui rend la tâche complexe pour un ordinateur.

	Nous allons ici voir quelques techniques de séparation de source (qui ne font pas intervenir de deep learning).

	<section title="Harmonic / Percussive Source Separation (HPSS)">

	La séparation harmonique / percussive consiste - comme son nom l'indique - à séparer un morceau de musiques en deux composantes :
	- une composante **harmonique**, correspondant aux parties mélodiques du morceau : voix, guitare, piano, basse...
	- une composante **percussive**, correspondant aux percussions présentes dans le morceau : caisse claire, grosse caisse, cymbales...

	Cette méthode est basée sur les constats suivants :
	- un son harmonique varie peu au cours du temps : on observe des lignes horizontales sur son spectrogramme
	- un son percussif est bref dans le temps, mais riche en fréquences : on observe des lignes verticales sur son spectrogramme

	<figure>
		<img src="assets/hpss/spectrogrammes.png" alt="">
		<figcaption>Spectrogrammes d'un son de violon (à gauche), d'un son de batterie (au milieu) et de leur superposition (à droite)</figcaption>
	</figure>

	Notre but est d'essayer de retrouver ces deux composantes à partir de leur mélange :

	<figure>
		<img src="assets/hpss/superposition.png" alt="">
		<figcaption>Spectrogramme de la superposition d'un son de violon et d'un son de batterie</figcaption>
	</figure>

	Voyons comment procéder.

	Dans un premier temps, on renforce les composantes horizontales / harmoniques (resp. verticales / percussives) en appliquant un filtre médian sur les colonnes (resp. sur les lignes) :

	<figure>
		<img src="assets/hpss/filtrages.png" alt="">
		<figcaption>Spectrogramme filtré avec un filtre médian sur les lignes (à gauche) et sur les colonnes (à droite)</figcaption>
	</figure>

	À partir de ces filtrages, on peut créer deux masques binaires correspondants aux parties harmoniques et percussives :

	$$
	\begin{align}
	M_h(i,j) :=
		\begin{cases}
		1 	& \text{si } \tilde{\mathbf{S}}_h(i,j) \geq \tilde{\mathbf{S}}_p(i,j) \\
		0	& \text{sinon}
		\end{cases} \\
	M_p(i,j) :=
		\begin{cases}
		1	& \text{si } \tilde{\mathbf{S}}_p(i,j) \geq \tilde{\mathbf{S}}_h(i,j) \\
		0	& \text{sinon}
		\end{cases}
	\end{align}
	$$

	<figure>
		<img src="assets/hpss/masques.png" alt="">
		<figcaption>Masques binaires</figcaption>
	</figure>

	Enfin, on peut appliquer ces masques sur le spectrogramme de départ pour récupérer nos deux composantes :

	<figure>
		<img src="assets/hpss/resultat.png" alt="">
		<figcaption>Composantes harmonique et percussive</figcaption>
	</figure>





	<section title="Résultats">

		<table>
			<thead>
				<tr>
					<th>Morceau</th>
					<th>Original</th>
					<th>Harmonique</th>
					<th>Percussive</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>Billie Jean - Michael Jackson</td>
					<td><audio src="assets/hpss/billie.wav" controls></audio></td>
					<td><audio src="assets/hpss/billie_h.wav" controls></audio></td>
					<td><audio src="assets/hpss/billie_p.wav" controls></audio></td>
				</tr>
			</tbody>
		</table>

	</section>


	<section title="Extensions">

	</section>

	<section title="Applications">

		Les résultats obtenus par cet algorithme ne sont pas exploitables tels quels. Cependant, on peut les utiliser dans les applications suivantes :
		- Retoucher le "*mixage*" d'un morceau
		- Retranscrire une partition : la partie percussive peut alors être mise de côté le temps de détecter les notes qui composent le morceau
		- À l'inverse, pour détecter le tempo d'un morceau, on peut mettre de côté la composante harmonique

	</section>

</section>
	<section title="2D Fourier Transform (2DFT)">
<!-- Séparation premier-plan (voix) / arrière-plan (musique) -->

	Nous allons voir ici une méthode permettant de séparer la voix d'un accompagnement musical.

	Cette méthode est basée sur le constat suivant : l'accompagnement musical d'un morceau de musique est souvent répétitif (boucles), tandis que le chant ne l'est pas. Cela peut se vérifier sur le spectrogramme suivant :

	<figure>
		<img src="assets/2dft/spectrogramme.png" alt="">
		<figcaption>Spectrogramme d'un extrait de Billie Jean, de Michael Jackson</figcaption>
	</figure>

	L'idée est d'alors d'isoler les composantes qui se répètent dans un spectrogramme (qui doivent logiquement faire partie de l'accompagnement musical).

	Une manière élégante d'y parvenir est de prendre la transformée de Fourier 2D de ce spectrogramme $\widetilde{X}(s,r) \coloneqq \mathcal{FT}_{2D} \{ X(f, t) \}$. En effet, la transformée de Fourier permet d'identifier les composantes périodiques d'un signal :

	<figure>
		<img src="assets/2dft/2dft.png" alt="">
		<figcaption>Transformée de Fourier 2D du module du spectrogramme précédent</figcaption>
	</figure>

	Les pics de $\widetilde{X}$ correspondent donc aux composantes répétitives du morceau. Il suffit alors d'identifier ces pics.

	Une manière d'y arriver est de comparer l'écart entre le maximum et le minimum du module de cette transformée sur un voisinage $V(c) = (v_x, v_y))$ avec un seuil $\gamma$.

	Autrement dit, soit :
	$$ \alpha(s, r) = \max_{V(s, r)} |\widetilde{X}(s',r')| - \min_{V(s, r)} |\widetilde{X}(s',r')| $$

	On construit un masque d'arrière-plan tel que :
	$$
	M_{bg}(s, r) = \begin{cases}
		1 &\text{si } \alpha(s, r) \gt \gamma \text{ et } |\widetilde{X}(s,r)| = \max_{V(s,r)} |\widetilde{X}(s',r')| \\
		0 &\text{sinon}
	\end{cases}
	$$

	Puis un masque d'avant-plan :
	$$ M_{fg} = 1 - M_{bg} $$

	Ces masques, appliqués à $\widetilde{X}$ permettent de séparer cette transformée :

	<figure>
		<img src="assets/2dft/separated_2dft.png" alt="">
		<figcaption>Séparation de $\widetilde{X}$</figcaption>
	</figure>

	En appliquant la transformée inverse, on se retrouve avec deux "presque-spectrogrammes", $X_{bg}$ et $X_{fg}$ correspondant à l'arrière-plan et à l'avant-plan :

	<figure>
		<img src="assets/2dft/separated_spectrograms.png" alt="">
		<figcaption>"Presque-spectrogrammes" séparés</figcaption>
	</figure>

	Cependant, ces "presque-spectrogrammes" contiennent "trop" d'informations par rapport à ce que nous voulons. Nous les utilisons pour construire deux nouveaux masques que l'on appliquera au spectrogramme $X$ :
	$$
	M_{bg}(f, t) = \begin{cases}
		1 &\text{si } X_{bg}(f,t) \gt X_{fg}(f,t) \\
		0 &\text{sinon}
	\end{cases}
	$$

	$$ M_{fg} = 1 - M_{bg} $$

	On les applique à $X$ pour obtenir les deux spectrogrammes finaux :

	<figure>
		<img src="assets/2dft/separated_spectrograms_2.png" alt="">
		<figcaption>"Spectrogrammes" séparés</figcaption>
	</figure>

	<section title="Résultats">

		<table>
			<thead>
				<tr>
					<th>Morceau</th>
					<th>Original</th>
					<th>Arrière-plan</th>
					<th>Avant-plan</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>Billie Jean - Michael Jackson</td>
					<td><audio src="assets/2dft/billie.wav" controls></audio></td>
					<td><audio src="assets/2dft/billie_bg.wav" controls></audio></td>
					<td><audio src="assets/2dft/billie_fg.wav" controls></audio></td>
				</tr>
			</tbody>
		</table>

	</section>

</section>
</section>	<section title="Références" no-count>

	<ul>
		<li>
			<cite id="wiki_son">
				<a href="https://fr.wikipedia.org/wiki/Son_(physique)">Page wikipédia sur le son</a>
			</cite>
		</li>
		<li>
			<cite id="hpss">
				<a href="http://dafx10.iem.at/papers/DerryFitzGerald_DAFx10_P15.pdf">Fitzgerald, Derry. “Harmonic/percussive separation using median filtering.”</a>
			</cite>
		</li>
		<li>
			<cite id="2dft">
				<a href="https://pseeth.github.io/public/papers/seetharaman_2dft_waspaa2017.pdf">Seetharaman, Prem, Fatemeh Pishdadian et Bryan Pardo. “Music/Voice Separation Using the 2D Fourier Transform.”</a>
			</cite>
		</li>
	</ul>

</section>
	<!-- <section title="Séparation de sources">

		
	
</section>	<section title="Reconstruction">

		
</section>	 -->

</section>		</article>

		<!-- CE -->
		<script src="/js/titles.js" charset="utf-8"></script>
	</body>
</html>
